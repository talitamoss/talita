package com.core.talita;

import android.content.Context;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import android.util.Log;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import java.nio.charset.StandardCharsets;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.util.Arrays;

/**
 * Secure Key Manager - Hardware-backed encryption for Talita
 *
 * Features:
 * - Hardware-backed keys (can't be extracted from device)
 * - AES-256-GCM encryption (authenticated encryption)
 * - Automatic key generation and management
 * - Secure memory handling
 */
public class SecureKeyManager {

    private static final String TAG = "SecureKeyManager";
    private static final String ANDROID_KEYSTORE = "AndroidKeyStore";
    private static final String KEY_ALIAS = "TalitaMasterKey";
    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;

    private final Context context;
    private KeyStore keyStore;

    public SecureKeyManager(Context context) {
        this.context = context;
        initializeKeyStore();
    }

    /**
     * Initialize Android Keystore and create master key if needed
     */
    private void initializeKeyStore() {
        try {
            keyStore = KeyStore.getInstance(ANDROID_KEYSTORE);
            keyStore.load(null);

            // Create master key if it doesn't exist
            if (!keyStore.containsAlias(KEY_ALIAS)) {
                generateMasterKey();
                Log.d(TAG, "‚úÖ Generated new hardware-backed master key");
            } else {
                Log.d(TAG, "‚úÖ Using existing hardware-backed master key");
            }

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Failed to initialize keystore: " + e.getMessage());
            throw new RuntimeException("Keystore initialization failed", e);
        }
    }

    /**
     * Generate hardware-backed master key
     */
    private void generateMasterKey() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES,
                ANDROID_KEYSTORE
        );

        KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(
                KEY_ALIAS,
                KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT
        )
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .setKeySize(256) // AES-256
                .setRandomizedEncryptionRequired(true)
                .setUserAuthenticationRequired(false) // For background operation
                .build();

        keyGenerator.init(keyGenParameterSpec);
        keyGenerator.generateKey();

        Log.d(TAG, "üîê Hardware-backed AES-256 key generated");
    }

    /**
     * Encrypt data using hardware-backed key
     * Returns: IV (12 bytes) + Encrypted Data + Auth Tag (16 bytes)
     */
    public byte[] encrypt(byte[] plaintext) {
        if (plaintext == null || plaintext.length == 0) {
            throw new IllegalArgumentException("Plaintext cannot be null or empty");
        }

        try {
            // Get the hardware-backed key
            SecretKey secretKey = (SecretKey) keyStore.getKey(KEY_ALIAS, null);

            // Initialize cipher for encryption
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);

            // Get the IV generated by the cipher
            byte[] iv = cipher.getIV();

            // Encrypt the data
            byte[] ciphertext = cipher.doFinal(plaintext);

            // Combine IV + ciphertext (ciphertext includes auth tag in GCM mode)
            byte[] encryptedData = new byte[iv.length + ciphertext.length];
            System.arraycopy(iv, 0, encryptedData, 0, iv.length);
            System.arraycopy(ciphertext, 0, encryptedData, iv.length, ciphertext.length);

            // Clear sensitive data
            Arrays.fill(plaintext, (byte) 0);

            Log.d(TAG, "üîí Data encrypted (" + encryptedData.length + " bytes)");
            return encryptedData;

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Encryption failed: " + e.getMessage());
            throw new RuntimeException("Encryption failed", e);
        }
    }

    /**
     * Decrypt data using hardware-backed key
     */
    public byte[] decrypt(byte[] encryptedData) {
        if (encryptedData == null || encryptedData.length < GCM_IV_LENGTH + GCM_TAG_LENGTH) {
            throw new IllegalArgumentException("Invalid encrypted data");
        }

        try {
            // Extract IV and ciphertext
            byte[] iv = new byte[GCM_IV_LENGTH];
            byte[] ciphertext = new byte[encryptedData.length - GCM_IV_LENGTH];

            System.arraycopy(encryptedData, 0, iv, 0, GCM_IV_LENGTH);
            System.arraycopy(encryptedData, GCM_IV_LENGTH, ciphertext, 0, ciphertext.length);

            // Get the hardware-backed key
            SecretKey secretKey = (SecretKey) keyStore.getKey(KEY_ALIAS, null);

            // Initialize cipher for decryption
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParameterSpec);

            // Decrypt the data
            byte[] plaintext = cipher.doFinal(ciphertext);

            Log.d(TAG, "üîì Data decrypted (" + plaintext.length + " bytes)");
            return plaintext;

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Decryption failed: " + e.getMessage());
            throw new RuntimeException("Decryption failed", e);
        }
    }

    /**
     * Encrypt string data
     */
    public byte[] encryptString(String plaintext) {
        if (plaintext == null) return null;
        return encrypt(plaintext.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Decrypt to string
     */
    public String decryptToString(byte[] encryptedData) {
        if (encryptedData == null) return null;
        byte[] plaintext = decrypt(encryptedData);
        String result = new String(plaintext, StandardCharsets.UTF_8);

        // Clear sensitive data
        Arrays.fill(plaintext, (byte) 0);

        return result;
    }

    /**
     * Check if encryption is available and working
     */
    public boolean isEncryptionAvailable() {
        try {
            // Test encrypt/decrypt cycle
            String testData = "test";
            byte[] encrypted = encryptString(testData);
            String decrypted = decryptToString(encrypted);

            boolean success = testData.equals(decrypted);
            Log.d(TAG, success ? "‚úÖ Encryption test passed" : "‚ùå Encryption test failed");

            return success;

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Encryption test failed: " + e.getMessage());
            return false;
        }
    }

    /**
     * Get encryption info for debugging
     */
    public String getEncryptionInfo() {
        try {
            return String.format(
                    "Encryption: AES-256-GCM\nKeystore: Android Hardware\nKey: %s\nStatus: %s",
                    keyStore.containsAlias(KEY_ALIAS) ? "Present" : "Missing",
                    isEncryptionAvailable() ? "Working" : "Failed"
            );
        } catch (Exception e) {
            return "Encryption Status: Error - " + e.getMessage();
        }
    }
}